<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="设计模式的艺术一书的阅读笔记, 造梦空间">
    <meta name="description" content="UML类图（Class Diagram） 是出现在系统中的不同类来描述系统的静态结构，主要用来描述不同的类以及它们之间的关系。
UML 属性的表示方式：
可见性（+：public、-：private、#：protected） 名称:类型[&amp;">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="referrer" content="no-referrer-when-downgrade">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>设计模式的艺术一书的阅读笔记 | 造梦空间</title>
    <link rel="icon" type="image/png" href="/favicon.png">
    


    <!-- bg-cover style     -->



<link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.min.css">
<link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
<link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
<link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
<link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
<link rel="stylesheet" type="text/css" href="/css/matery.css">
<link rel="stylesheet" type="text/css" href="/css/my.css">
<link rel="stylesheet" type="text/css" href="/css/dark.css" media="none" onload="if(media!='all')media='all'">




    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
    <link rel="stylesheet" href="/css/post.css">




    



    <script src="/libs/jquery/jquery-3.6.0.min.js"></script>

<meta name="generator" content="Hexo 7.3.0"><link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head>


<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">造梦空间</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/contact" class="waves-effect waves-light">
      
      <i class="fas fa-comments" style="zoom: 0.6;"></i>
      
      <span>留言板</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友情链接</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
  <li>
    <a href="javascript:;" class="waves-effect waves-light" onclick="switchNightMode()" title="深色/浅色模式" >
      <i id="sum-moon-icon" class="fas fa-sun" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">造梦空间</div>
        <div class="logo-desc">
            
            Never really desperate, only the lost of the soul.
            
        </div>
    </div>

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/contact" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-comments"></i>
			
			留言板
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友情链接
		</a>
          
        </li>
        
        
    </ul>
</div>


        </div>

        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/8.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">设计模式的艺术一书的阅读笔记</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/Notes/">
                                <span class="chip bg-color">Notes</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/Reading/" class="post-category">
                                Reading
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2024-03-11
                </div>
                

                

                
                <div class="info-break-policy">
                    <i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp;
                    11.2k
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-clock fa-fw"></i>阅读时长:&nbsp;&nbsp;
                    43 分
                </div>
                

                
            </div>
        </div>
        <hr class="clearfix">

        
        <!-- 是否加载使用自带的 prismjs. -->
        <link rel="stylesheet" href="/libs/prism/prism.min.css">
        

        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <h2 id="UML"><a href="#UML" class="headerlink" title="UML"></a>UML</h2><p><strong>类图（Class Diagram）</strong> 是出现在系统中的不同类来描述系统的静态结构，主要用来描述不同的类以及它们之间的关系。</p>
<p>UML 属性的表示方式：</p>
<pre class="line-numbers language-none"><code class="language-none">可见性（+：public、-：private、#：protected） 名称:类型[&#x3D;默认值]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>UML 方法的表示方式：</p>
<pre class="line-numbers language-none"><code class="language-none">可见性 名称(参数列表)[: 返回类型]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="类之间的关系"><a href="#类之间的关系" class="headerlink" title="类之间的关系"></a>类之间的关系</h3><p>关联关系（Association）：（一个对象作为另一个对象的成员变量）</p>
<p>双向关联、单向关联、自关联、多重关联、聚合关系（整体和部分关系，部分可独立存在）、组合关系（在类中实例化另一个对象，共存亡）</p>
<p>依赖关系（Dependency）：（使用另一个类作为参数、将另一个类对象作为局部变量、调用另一个类的静态方法）</p>
<p>泛化关系（Generalization）又称继承关系：（描述父类和子类之间的关系）</p>
<p>接口与实现关系</p>
<h2 id="面向对象设计原则"><a href="#面向对象设计原则" class="headerlink" title="面向对象设计原则"></a>面向对象设计原则</h2><h3 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h3><p>单一职责原则（Single Responsibility Principle，SRP）：一个类只负责一个功能领域中的相应职责。或者可以定义为：就一个类而言只有一个引起它变化的原因。</p>
<p>单一职责原则是实现高内聚、低耦合的指导方针，它是最简单又是最难运用的原则，需要设计人员发现类的不同的职责并将其分离。</p>
<h3 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h3><p>开闭原则（Open-Closed Principle，OCP）：一个软件实体应当对扩展开放，对修改关闭。即软件实体应尽量在不修改原有代码的情况下进行扩展。</p>
<p>抽象化是开闭原则的关键。面向接口编程，在新需求到来时不需要改动抽象层而是添加具体的实现类即可完成。</p>
<h3 id="里氏代换原则"><a href="#里氏代换原则" class="headerlink" title="里氏代换原则"></a>里氏代换原则</h3><p>里氏代换原则（Liskov Substitution Principle，LSP）：所有引用基类（父类）的地方必须能透明地使用其子类的对象。</p>
<p>在软件中将一个基类对象替换为它的子类对象，程序将不会产生任何错误和异常，在程序中尽量使用基类类型来对对象进行定义，而在运行时再确定其子类类型，用子类对象来替换父类对象。（多态的感觉），这样扩展功能可通过增加一个新的子类来实现。</p>
<h3 id="依赖倒转原则"><a href="#依赖倒转原则" class="headerlink" title="依赖倒转原则"></a>依赖倒转原则</h3><p>依赖倒转原则（Dependency Inversion Principle，DIP）：抽象不应该依赖于细节，细节应当依赖于抽象。换言之，要针对接口编程而不是实现编程。</p>
<h3 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h3><p>接口隔离原则（Interface Segregation Principle，ISP）：使用多个专门的接口，而不是使用单一的总接口，即客户端不应该依赖那些它不需要的接口。</p>
<h3 id="合成复用原则"><a href="#合成复用原则" class="headerlink" title="合成复用原则"></a>合成复用原则</h3><p>合成复用原则（Composition Resuse Principle，CRP）：尽量使用对象组合，而不是继承达到复用的目的</p>
<h3 id="迪米特法则"><a href="#迪米特法则" class="headerlink" title="迪米特法则"></a>迪米特法则</h3><p>迪米特法则（Law of Demeter，LoD）：一个软件实体应当尽可能少地与其他实体发生相互作用。</p>
<p>当一个模块发生修改时，尽量少得影响其他模块，扩展和重构更加容易，即限制软件实体间的通信。</p>
<h2 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a>创建型模式</h2><h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><p>单例模式（Singleton Pattern）：确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，这个类称为单例类，它提供全局访问的方法。单例模式是一种对象创建型模式。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; Java 饿汉式，类加载时即实例化，占用系统资源
class EagerSingleton&#123;
    private static final EagerSingleton instance &#x3D; new EagerSingleton();
    private EagerSingleton()&#123;&#125;
    public static EagerSingleton getInstance()&#123;
        return instance;
    &#125;
&#125;

&#x2F;&#x2F; 双重检查锁定（Double-Check Locking），使用锁机制，性能有一定影响
class LazySingleton&#123;
    private volatile static LazySingleton instance &#x3D; null;
    private LazySingleton()&#123;&#125;
    public static LazySingleton getInstance()&#123;
        if(instance &#x3D;&#x3D; null)&#123;
            synchronized(LazySingleton.class)&#123;
                if(instance &#x3D;&#x3D; null)&#123;
                    instance &#x3D; new LazySingleton();
                &#125;
            &#125;
        &#125;
        return instance;
    &#125;
&#125;

&#x2F;&#x2F; 静态内部类机制
class Singleton&#123;
    private Singleton()&#123;&#125;
    private static class InnerClass&#123;
        private final static Singleton instance &#x3D; new Singleton();
    &#125;
    private static Singleton getInstance()&#123;
        return InnerClass.instance;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>优点：</p>
<ol>
<li>提供对唯一实例的受控访问。</li>
<li>系统中只存在一个对象，节约系统资源。</li>
<li>允许可变数目的实例（自行提供指定数目实例对象的类可称之为多例类）。</li>
</ol>
<p>缺点：</p>
<ol>
<li>单例模式没有抽象层，难以扩展。</li>
<li>单例类职责过重，将对象的创建和对象本身的功能耦合在一起。</li>
<li>对于自动垃圾回收，如果实例化共享对象长时间不被利用会被回收，下次使用又需要实例化，导致共享的单例对象状态丢失。</li>
</ol>
<p>适用场景：</p>
<ol>
<li>系统只需要一个实例对象。</li>
<li>客户调用类的单个实例只允许一个公共访问点。</li>
</ol>
<h3 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h3><p>简单工厂模式（Simple Factory Pattern）：定义一个工厂类，它可以根据参数的不同返回不同类的实例，被创建的实例通常都具有共同的父类。因为在简单工厂模式中用于创建实例的方法是静态方法，因此简单工厂模式又称为静态工厂模式（Static Factory Method Pattern）。</p>
<ul>
<li>Factory（工厂角色）</li>
<li>Product（抽象产品角色）</li>
<li>ConcreteProduct（具体产品角色）</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 定义产品抽象
public interface Product&#123;
    
&#125;

&#x2F;&#x2F; 定义具体的产品
public class ConcreteProductA implements Product&#123;
    
&#125;
public class ConcreteProductB implements Product&#123;
    
&#125;

&#x2F;&#x2F; 定义工厂
class Factory&#123;
    public static Product getProduct(String arg)&#123;
        Product product &#x3D; null;
        if(&quot;A&quot;.equals(arg))&#123;
            product &#x3D; new ConcreteProductA();
        &#125;else if(&quot;B&quot;.equals(arg))&#123;
            product &#x3D; new ConcreteProductB();
        &#125;
        
        return product;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>优点：</p>
<ol>
<li>实现了对象创建和使用的分离，客户端只需要专注于使用产品</li>
<li>客户端无需知道所创建的具体产品的类名，而只需知道如何使用即可，减少了使用者的记忆量</li>
<li>引入配置文件可在不修改任何客户端代码的情况下进行更换和增加的新的具体产品类，在一定程度上提高了系统的灵活性</li>
</ol>
<p>缺点：</p>
<ol>
<li>工厂类集中了所有产品的创建逻辑，职责过重，一旦不能工作，整个系统都将受到影响</li>
<li>简单工厂模式会增加系统类的个数</li>
<li>系统扩展困难，增加新产品不得不修改工厂逻辑</li>
<li>简单工厂模式使用静态工厂方法，无法形成基于继承等级结构</li>
</ol>
<p>适用场景：</p>
<ol>
<li>工厂类负责创建的对象比较少，由于创建的对象较少，不会造成工厂方法中的业务逻辑太过复杂</li>
<li>客户端只知道传入工厂类的参数，而不关系对象如何被创建</li>
</ol>
<h3 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h3><p>工厂方法模式（Factory Method Pattern）：定义一个用于创建对象的接口，让子类决定将哪一个类实例化。工厂方法模式让一个类的实例化延迟到子类。工厂方法模式又称工厂模式（Factory Pattern）</p>
<ul>
<li>Product（抽象产品）</li>
<li>ConcreteProduct（具体产品）</li>
<li>Factory（抽象工厂）</li>
<li>ConcreteFactory（具体工厂）</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 抽象产品
interface Logger&#123;
    public void writeLog();
&#125;

&#x2F;&#x2F; 具体产品
class DatabaseLogger implements Logger&#123;
    public void writeLog()&#123;
        System.out.println(&quot;数据库日志记录&quot;);
    &#125;
&#125;

class FileLogger implements Logger &#123;
    public void writeLog()&#123;
        System.out.println(&quot;文件日志记录&quot;);
    &#125;
&#125;

&#x2F;&#x2F; 抽象工厂
interface LoggerFactory&#123;
    public Logger createLogger();
&#125;

&#x2F;&#x2F; 具体工厂
class DatabaseLoggerFactory implements LoggerFactory&#123;
    public Logger createLogger()&#123;
        Logger logger &#x3D; new DatabaseLogger();
        return logger;
    &#125;
&#125;

&#x2F;&#x2F; 具体工厂
class FileLoggerFactory implements LoggerFactory&#123;
    public Logger createLogger()&#123;
        Logger logger &#x3D; new FileLogger();
        return logger;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>优点：</p>
<ol>
<li>用户只需关心所需产品对应的工厂，无需关心创建细节甚至是具体的产品类名。</li>
<li>基于工厂角色和产品角色的多态性设计是工厂方法模式的关键。</li>
<li>当添加新产品时，只需添加新的产品具体类和具体工厂即可，完全符合开闭原则。</li>
</ol>
<p>缺点：</p>
<ol>
<li>当添加新产品的时候需要编写新的具体产品类和具体工厂，一定程度上增加了系统的复杂度</li>
<li>抽象层增加了系统的抽象性和理解难度（？我怎么感觉抽象更好）</li>
</ol>
<p>适用场景：</p>
<ol>
<li>客户端不需要知道所需要的对象的类</li>
<li>抽象工厂类通过其子类来指定创建哪个对象（面向对象多态和里氏代换原则）</li>
</ol>
<h3 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h3><p>抽象工厂模式（Abstract Factory Pattern）：提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。抽象工厂模式又称为 Kit 模式，它是一种对象创建型模式。</p>
<ul>
<li>AbstractFactory（抽象工厂）</li>
<li>ConcreteFactory（具体工厂）</li>
<li>AbstractProduct（抽象产品）</li>
<li>ConcreteProduct（具体产品）</li>
</ul>
<p>抽象工厂声明一组创建一族产品的方法</p>
<p>具体工厂实现创建一族产品的具体方法</p>
<p>添加产品族只需要继承或实现抽象工厂即可，符合开闭原则</p>
<p>添加产品等级结构需要改抽象工厂，一改动全身，不符合开闭原则</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 抽象工厂
abstract class AbstractFactory &#123;
    public abstract AbstractProductA createProductA();
    public abstract AbstractProductB createProductB();
&#125;

&#x2F;&#x2F; 具体工厂
class ConcreteFactory1 extends AbstractFactory &#123;
    public AbstractProductA createProductA()&#123;
        return new ConcreteProductA1();
    &#125;
    
    public AbstractProductB createProductB()&#123;
        return new ConcreteProductB1();
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>优点：</p>
<ol>
<li>抽象工厂模式隔离了具体类的生成，改变具体工厂的实例就可以改变系统行为</li>
<li>当一个产品族被设计一起工作时，它能保证客户端始终使用用一个产品族的对象</li>
<li>增加新的产品族很方便，无需修改已有系统</li>
</ol>
<p>缺点：</p>
<ol>
<li>增加新的产品等级结构麻烦，需要对原有系统进行较大的修改，甚至需要修改抽象层代码，违背开闭原则</li>
</ol>
<p>适用场景：</p>
<ol>
<li>系统不依赖于产品类实例的创建的细节</li>
<li>系统中有多于一个的产品族，且每次只使用一个产品族</li>
<li>属于一个产品族的产品一起使用，这一约束必须在系统设计中体现出来</li>
<li>产品等级结构稳定，设计完成之后，不会再向系统中增加或删除等级结构</li>
</ol>
<h3 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h3><p>原型对象（Prototype Pattern）：使用原型实例指定创建对象的种类，并且通过克隆这些原型创建新的对象。</p>
<ul>
<li>Prototype（抽象原型类）</li>
<li>ConcretePrototype（具体原型类）</li>
</ul>
<p>优点：</p>
<ol>
<li>当创建一个新的对象实例较为复杂时，是原型模式通过复制一个现有的实例可以提高新实例的创建效率</li>
<li>扩展性好，面向抽象原型类进行编程，在增加或较少具体原型类对系统没有任何影响</li>
<li>原型模式提供简单的创建结构</li>
<li>可以使用深克隆的方式保存对象的状态</li>
</ol>
<p>缺点：</p>
<ol>
<li>每一类需要配备一个克隆方法，克隆方法位于类的内部，改造时需要修改，违背开闭原则</li>
<li>实现深克隆需要层层遍历，实现可能比较麻烦</li>
</ol>
<p>适用场景：</p>
<ol>
<li>创建新对象的成本比较大</li>
<li>系统需要保存对象的状态，而对象的状态很小，可以使用原型模式加备忘录模式</li>
<li>需要避免使用分层次的工厂类创建分层次的对象</li>
</ol>
<h3 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h3><p>建造者模式（Builder Pattern）：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。</p>
<ul>
<li>Builder（抽象建造者）：它为创建一个产品的 Product 对象的各个部件指定抽象方法</li>
<li>ConcreteBuilder（具体建造者）</li>
<li>Product（产品角色）</li>
<li>Director（指挥者），指挥如何创建</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 产品
class Product&#123;
    private String partA;
    private String partB;
    private String partC;
    
    &#x2F;&#x2F;getter&#x2F;setter
&#125;

&#x2F;&#x2F; 抽象建造类
abstract class Builder&#123;
    protected Product product &#x3D; new Product();
    
    public abstract void buildPartA();
    public abstract void buildPartB();
    public abstract void buildPartC();
    
    public Product getResult()&#123;
        return product;
    &#125;
&#125;

&#x2F;&#x2F; 指挥类
class Director&#123;
    private Builder builder;
    
    public Director(Builder builder)&#123;
        this.builder &#x3D; builder;
    &#125;
    
    public void setBuilder(Builder builder)&#123;
        this.builder &#x3D; builder;
    &#125;
    
    public Product construct()[
        builder.buildPartA();
        builder.buildPartB();
        builder.buildPartC();
        return builder.getResult();
    ]
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>优点：</p>
<ol>
<li>使用相同的创建过程，不同的具体建造类可以创建不同的产品对象</li>
<li>建造者之间相对独立，系统扩展方便，符合开闭原则</li>
<li>可以精细控制产品的创建过程</li>
</ol>
<p>缺点：</p>
<ol>
<li>如果产品的组成部分差异性大，不适合使用建造者模式</li>
<li>如果产品内部结构复杂且多变，使用建造者模式会使系统变得很庞大</li>
</ol>
<p>适用场景：</p>
<ol>
<li>需要生成的产品对象有复杂的内部结构</li>
<li>需要生成的产品对象属性相互依赖，需要指定其生成顺序</li>
<li>建造者模式通过引入指挥者类，将创建过程与建造者类和客户端分离开来</li>
<li>使用相同的步骤创建不同的产品</li>
</ol>
<h2 id="结构性模式"><a href="#结构性模式" class="headerlink" title="结构性模式"></a>结构性模式</h2><h3 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h3><p>适配器模式（Adapter Pattern）：将一个接口转换成客户端希望的另一个接口，使接口不兼容的那些类可以一起工作，其别名为包装类（Wrapper）。</p>
<ul>
<li>Target（目标抽象类）</li>
<li>Adapter（适配器类）</li>
<li>Adaptee（适配者类）</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 对象适配器模式，通过与待适配对象实现关联关系
class Adapter extends Target &#123;
    private Adaptee adaptee;
    
    public Adapter(Adaptee adaptee)&#123;
        this.adaptee &#x3D; adaptee;
    &#125;
    public void request()&#123;
        adaptee.specificRequest();
    &#125;
&#125;

&#x2F;&#x2F; 类适配器模式
class Adapter extends Adaptee implements Target &#123;
    public void request()&#123;
        specificRequest();
    &#125;
&#125;

&#x2F;&#x2F; 双向适配器模式
class Adapter implements Target,Adaptee &#123;
    private Target target;
    private Adaptee adaptee;
    
    public Adapter(Target target)&#123;
        this.target &#x3D; target;
    &#125;
    
    public Adapter(Adaptee adaptee)&#123;
        this.adaptee &#x3D; adaptee;
    &#125;
    
    public void request()&#123;
        adaptee.specificRequest();
    &#125;
    
    public void specificRequest()&#123;
        target.request();
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>缺省适配器模式（Default Adapter Pattern）：当不需要实现一个接口所提供的所有方法时，可先设计一个抽象实现该接口，并为接口中的每个方法提供一个默认实现，那么该抽象类的子类可以选择性地覆盖父类的某些方法来实现需求，它适用于不想使用一个接口中的所有方法得到情况。</p>
<ul>
<li>ServiceInterface（适配器接口）</li>
<li>AbstractServiceClass（缺省适配器类）</li>
<li>ConcreteServiceClass（具体业务类）</li>
</ul>
<p>优点：</p>
<ol>
<li>引用适配器类重用现有的适配类，无需修改原有结构</li>
<li>将具体的业务封装在适配者类中，提高适配者类的复用性</li>
<li>对于对象适配器模式可以将多个不同的适配者适配到同一个目标</li>
</ol>
<p>缺点：</p>
<ol>
<li>不支持多继承的语言，一个类最多只能适配一个适配者类</li>
<li>适配者不能是最终类</li>
<li>类适配器模式的目标抽象类只能是接口</li>
<li>对象适配模式在适配一个适配者类时可以先创建一个适配者类的子类进行方法的覆盖，再对适配者子类进行适配，实现过程复杂</li>
</ol>
<p>适用场景：</p>
<ol>
<li>系统需要使用一些现有的类，而这些类的接口不符合系统的需要</li>
<li>创建一个重复使用的类，用于一些彼此没有太大关联的类</li>
</ol>
<h3 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h3><p>桥接模式（Bridge Pattern）：将抽象部分与其实现部分分离，使它们都可以独立地变化。它是一个对象结构型模式，又称为柄体（Handle and Body）模式或接口（Interface）模式。</p>
<ul>
<li>Abstraction（抽象类）</li>
<li>RefinedAbstraction（扩充抽象类）</li>
<li>Implementor（实现类接口）</li>
<li>ConcrateImplementor（具体实现类）</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 实现类接口
interface Implementor&#123;
    public void operationImpl();
&#125;

&#x2F;&#x2F; 抽象类
abstract class Abstraction &#123;
    protected Implementor impl;
    
    public void setImpl(Implementor impl)&#123;
        this.impl &#x3D; impl;
    &#125;
    
    public abstract void operation();
&#125;


&#x2F;&#x2F; 扩充抽象类
class RefinedAbstraction extends Abstraction &#123;
    public void operation()&#123;
        impl.operationImpl();
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>优点：</p>
<ol>
<li>分离抽象接口及其实现部分。</li>
<li>桥接模式可以取代多层继承方案</li>
<li>桥接模式提高了系统的可扩展性，在两个维度中任意扩展一个维度，都不要修改原有的系统。</li>
</ol>
<p>缺点：</p>
<ol>
<li>桥接模式增加了系统的理解和设计难度，需要开发者对抽象层进行设计和编程（感觉这是好处，觉得它难就是它的缺点我有点不赞同，要迎难而上）</li>
<li>需要正确识别系统中两个独立变化的维度</li>
</ol>
<p>适用场景：</p>
<ol>
<li>如果系统需要抽象类和具体类中增加更多的灵活性，避免在层次间继承关系，可以使用桥接模式在抽象层建立关联关系</li>
<li>抽象部分和实现部分可以以继承的方式单独扩展而互不影响</li>
<li>一个类存在两个或多个独立变化的维度</li>
<li>对于不希望使用继承或多层继承导致系统类急剧增加的系统，桥接模式尤为适用</li>
</ol>
<h3 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h3><p>组合模式（Composite Pattern）：组合多个对象形成树形结构以表示具有整体一部分关系的层次结构。组合模式对单个对象和组合对象的使用具有一致性，组合模式又称为整体-部分（Part-Whole）模式。</p>
<ul>
<li>Component（抽象构件）</li>
<li>Leaf（叶子构件）</li>
<li>Composite（容器构件）</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 抽象构件，客户端对抽象构件进行编程
abstract class Component&#123;
    public abstract void add(Component c);
    public abstract void remove(Component c);
    public abstract Component getChild(int i);
    public abstract void operation();
&#125;

&#x2F;&#x2F; 叶子构件
class Leaf extends Component &#123;
    public void add(Component c)&#123;

    &#125;
    public void remove(Component c)&#123;

    &#125;
    public Component getChild(int i)&#123;
		return null;
    &#125;
    public void operation()&#123;

    &#125;
&#125;

&#x2F;&#x2F; 容器构件
class Composite extends Component &#123;
    private ArrayList&lt;Component&gt; list &#x3D; new ArrayList&lt;Compontnt&gt;();
    
    public void add(Component c)&#123;
		list.add(c);
    &#125;
    public void remove(Component c)&#123;
		list.remove(c);
    &#125;
    public Component getChild(int i)&#123;
		return (Component)list.get(i);
    &#125;
    public void operation()&#123;
		for(Object obj: list)&#123;
            (Component)obj.operation();
        &#125;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>优点：</p>
<ol>
<li>组合模式可以清楚定义分层次的复杂对象</li>
<li>客户端一致地使用组合结构或单个对象</li>
<li>扩展增加新的容器构件和叶子构件方便</li>
<li>通过叶子对象和容器对象的递归组合，可形成复杂的树形结构</li>
</ol>
<p>缺点：</p>
<ol>
<li>增加新构件时难以对容器中的构建类进行限制</li>
</ol>
<p>适用场景：</p>
<ol>
<li>具体整体和部分层次结构中</li>
<li>使用面向对象语言系统处理树形结构</li>
<li>分离叶子对象和容器对象</li>
</ol>
<h3 id="装饰模式"><a href="#装饰模式" class="headerlink" title="装饰模式"></a>装饰模式</h3><p>装饰模式（Decorator Pattern）：动态地给一个对象增加一些额外的职责，就增加对象的功能来说，装饰模式比子类实现更为灵活。</p>
<ul>
<li>Component（抽象构件）</li>
<li>Decorator（抽象装饰类）</li>
<li>ConcreteDecorator（具体装饰类）</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 抽象装饰类
class Decorator implements Component&#123;
    private Component component;
    
    public Decorator(Component component)&#123;
        this.component &#x3D; component;
    &#125;
    
    public void opeartion()&#123;
        component.operation();
    &#125;
&#125;

&#x2F;&#x2F; 具体抽象类
class ConcreteDecorator extends Decorator&#123;
    public ConcreteDecorator(Component component)&#123;
        super(component);
    &#125;
    
    public void operation()&#123;
        super.operation();
        addedBehavior();
    &#125;
    
    public void addedBehavior()&#123;
        
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>注意事项：</p>
<ol>
<li>尽可能保持装饰类的接口和被装饰类的接口相同</li>
<li>尽量保持具体构件类是一个轻类</li>
<li>如果只有一个具体构件类，那么可以抽象装饰类直接作为该具体构件类的子类</li>
</ol>
<p>优点：</p>
<ol>
<li>扩展一个对象的功能相比较继承更灵活</li>
<li>可以通过动态的方法进行对象功能的扩展</li>
<li>可以对一个对象进行多次装饰</li>
<li>具体构件类和具体装饰类可以独立变化</li>
</ol>
<p>缺点：</p>
<ol>
<li>装饰模式会设置非常多小对象，不利于管理</li>
<li>装饰模式比继承更容易出错，排错更困难</li>
</ol>
<p>适用场景：</p>
<ol>
<li>在不像其他对象的情况下，动态、透明地给单个对象添加职责</li>
<li>不能采用继承的方式对系统进行扩展或采用继承对系统扩展和维护不利时</li>
</ol>
<h3 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h3><p>外观模式（Facade Pattern）：外部与一个子系统的通信通过一个统一的外观角色进行，为子系统中的一组接口提供一个一致的入口，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。（子系统是一个广义的概念，它可以是一个类、一个功能模块、系统的一个组成部分或者一个完整的系统）。</p>
<ul>
<li>Facade（外观角色）</li>
<li>SubSystem（子系统角色）</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">class Facade&#123;
    private SubSystemA obj1 &#x3D; new SubSystemA();
    private SubSystemB obj2 &#x3D; new SubSystemB();
    private SubSystemC obj3 &#x3D; new SubSystemC();
    
    public void method()&#123;
        obj1.method();
        obj2.method();
        obj3.method();
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>优点：</p>
<ol>
<li>客户端屏蔽了子系统组件，减少了客户端所需处理的对象数目</li>
<li>实现了子系统与客户端之间的松耦合关系，子系统变化不会影响到客户端</li>
<li>一个子系统的修改不会影响到其他子系统</li>
<li>只是提供了一个子系统的统一访问入口，不影响客户端直接使用子系统</li>
</ol>
<p>缺点：</p>
<ol>
<li>不能很好地限制客户端直接使用子系统</li>
<li>设计不当，可能导致增加新的子系统时可能需要修改外观类的源代码</li>
</ol>
<p>适用场景：</p>
<ol>
<li>当要为访问一系列复杂的子系统提供一个简单入口时</li>
<li>客户端程序与多个子系统存在很大的依赖性，利用外观模式解耦</li>
<li>在层次化结构中，使用外观模式定义系统中每一层的入口</li>
</ol>
<h3 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h3><p>享元模式（Flyweight Pattern）：运用共享技术有效地支持大量细粒度对象的复用。系统只是用少量的对象，而这些对象都很相似，状态变化很小，可以实现对象的多次复用。</p>
<ul>
<li>Flayweight（抽象享元类）</li>
<li>ConcreteFlyweight（具体享元类）</li>
<li>UnsharedConcreteFlyweight（非共享具体享元类）</li>
<li>FlyweightFactory（享元工厂类）</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 享元工厂类
class FlyweightFactory&#123;
    private HashMap flyweight &#x3D; new HashMap();
    
    public Flyweigth getFlyweight(String key)&#123;
        if(flyweight.containsKey(key))&#123;
            return (Flayweight)flyweight.get(key);
        &#125;else &#123;
            Flyweight fw &#x3D; new ConcreteFlyweight();
            flyweight.put(key, fw);
            return fw;
        &#125;
        
    &#125;
&#125;

&#x2F;&#x2F; 抽象享元类
class Flyweight &#123;
    private String intrinsicState;
    
    public Flyweight(String intrinsicState)&#123;
        this.intrinscState &#x3D; intrinsicState;
    &#125;
    
    public void operation(String extrinsicState)&#123;
        
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>优点：</p>
<ol>
<li>可以极大减少内存中对象的数量</li>
<li>享元模式的外部状态相对独立，不会影响其内部状态，从而使享元对象可以在不同环境被共享</li>
</ol>
<p>缺点：</p>
<ol>
<li>分离出内部状态和外部状态，使得程序逻辑变得复杂</li>
<li>为了对象共享，需要将享元对象的部分状态外部化</li>
</ol>
<p>适用场景：</p>
<ol>
<li>以恶系统中有大量相同或者相似的对象，造成内存的大量耗费</li>
<li>对象的大部分状态可以外部化，可以将这些外部状态传入到对象中</li>
<li>维护一个存储享元对象的享元池，需要耗费一定的系统资源，在需要多次重复使用享元对象才值得使用</li>
</ol>
<h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><p>代理模式（Proxy Pattern）：给某一个对象提供一个代理，并由代理对象控制原对象的引用。</p>
<ul>
<li>Subject（抽象主题角色）</li>
<li>Proxy（代理主题角色）</li>
<li>RealSubject（真实主题角色）</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">class Proxy implements Subject &#123;
    private RealSubject realSubject &#x3D; new RealSubject();
    
    public void preRequst()&#123;&#125;
    
    public void request()&#123;
        preRequest();
        realSubject.request();
        postRequest();
    &#125;
    
    public void postRequest()&#123;&#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>常用的代理模式：</p>
<ol>
<li>远程代理（Remote Proxy）：为一个不同的地址空间的对象提供一个本地的代理对象。远程代理又称为大使（Ambassador）。</li>
<li>虚拟代理（Virtual Proxy）：如果需要创建一个资源消耗较大的对象，先创建一个消耗较小的对象来表示，真实的对象只在需要时才会被真正创建。</li>
<li>保护代理（Protect Prxoy）：控制一个对象的访问，可以给不同的用户提供不同级别的使用权限。</li>
<li>缓冲代理（Cache Proxy）：为一个目标操作的结构提供临时的存储空间，以便多个客户端可以共享这些结构。</li>
<li>智能引用代理（Smart Reference Proxy）：当一个对象被引用时，提供一些额外操作。</li>
</ol>
<p>优点：</p>
<ol>
<li>代理模式协调调用者和被调用者，在一定程度降低系统的耦合度</li>
<li>客户端根据抽象主题角色编程，增加更换代理类无须修改源代码</li>
<li>远程代理位于两个不同地址空间对象的访问提供一个实现机制</li>
<li>虚拟代理通过一个消耗资源较少的对象来代表资源消耗较多的对象，节省系统开销</li>
<li>保护代理可以控制对一个对象的访问权限</li>
</ol>
<p>缺点：</p>
<ol>
<li>客户端和真实主题之间增加了代理对象，请求速度变慢。</li>
<li>实现代理模式需要额外的工作</li>
</ol>
<p>适用场景：</p>
<ol>
<li>当客户端需要访问远程主机对象时，使用远程代理</li>
<li>当需要一个消耗资源较少的对象来代表消耗资源较多的对象时，使用虚拟代理</li>
<li>当控制一个对象的访问，使用保护代理</li>
<li>当需要某一个频繁访问的操作结果提供临时存储空间使用缓冲代理</li>
<li>当需要为一个对象的访问提供一些额外操作时，使用智能引用代理</li>
</ol>
<h2 id="行为型模式"><a href="#行为型模式" class="headerlink" title="行为型模式"></a>行为型模式</h2><h3 id="职责链模式"><a href="#职责链模式" class="headerlink" title="职责链模式"></a>职责链模式</h3><p>职责链模式（Chain of Responsibility Pattern）：避免将请求发送者与接收者耦合在一起，让多个对象都有机会接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。</p>
<ul>
<li>Handler（抽象处理者）</li>
<li>ConcreteHandler（具体处理者）</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 抽象处理类
abstract class Handler &#123;
    protected Handler successor;
    
    public void setSuccessor(Handler successor)&#123;
        this.successor &#x3D; successor;
    &#125;
    public abstract void handleRequest(String request);
&#125;

&#x2F;&#x2F; 具体处理类
class ConcreteHandler extends Handler &#123;
    public void handleRequest(String reqeust)&#123;
        if(请求满足条件)&#123;
            &#x2F;&#x2F; 处理请求
        &#125;else &#123;
            this.successor.handleRequest(request); &#x2F;&#x2F; 转发请求
        &#125;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>优点：</p>
<ol>
<li>一个对象无需知道哪一个对象会处理此请求，客户端负责链的创建，降低了系统的耦合度</li>
<li>请求处理对象仅需维持一个其后继者的引用，而不需要维持所有的，简化对象连接</li>
<li>在系统中增加新的具体处理者无需修改原有系统的代码，只需客户端重新建链即可</li>
</ol>
<p>缺点：</p>
<ol>
<li>请求可能一直到末端也没有处理</li>
<li>对于长的职责链，代码调试不太方便</li>
<li>建链不当可能造成循环调用，导致系统陷入死循环</li>
</ol>
<p>适合场景：</p>
<ol>
<li>有多个对象可以处理同一个请求，具体哪个对象处理运行时确定，客户端无需知道是哪个具体对象处理</li>
<li>在不明确指定接收者的情况下，向多个对象中的提交一个请求</li>
<li>可动态指定一组对象处理请求，客户端可以改变链中处理者之间的先后次序</li>
</ol>
<h3 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h3><p>命令模式（Command Pattern）：将一个请求封装为一个对象，从而可用不同的请求对客户进行参数化；对请求排队或者记录请求日志，以及支持可撤销的操作。别名为动作（Action）模式或事务（Transaction）模式。</p>
<ul>
<li>Command（抽象命令类）</li>
<li>ConcreteCommand（具体命令类）</li>
<li>Invoker（调用者）</li>
<li>Receiver（接收者）</li>
</ul>
<p>命令模式的本质就是对请求进行封装，一个请求对应于一个命令，将发出的命令的职责和执行命令的责任分隔开。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 抽象命令类
abstract class Command &#123;
    public abstract void execute();
&#125;

&#x2F;&#x2F; 调用者
class Invoker &#123;
    private Command command;
    
    public Invoker(Command command)&#123;
        this.command &#x3D; command;
    &#125;
    
    public void setCommand(Command command)&#123;
        this.command &#x3D; command;
    &#125;
    
    public void call()&#123;
        command.execute();
    &#125;
&#125;

&#x2F;&#x2F; 具体命令类
class ConcreteCommand extends Command &#123;
    private Receiver receiver;
    
    public void execute()&#123;
        receiver.action();
    &#125;
&#125;

&#x2F;&#x2F; 接收者
class Reciver &#123;
    public void action()&#123;
        &#x2F;&#x2F; 具体操作
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>优点：</p>
<ol>
<li>降低系统耦合度，请求者和接收者之间不存在直接引用</li>
<li>新的命令可以很容易加到系统中</li>
<li>比较容易设计一个命令队列或宏命令（组合模式）</li>
<li>为请求的撤销和恢复操作设计一种设计和实现方案</li>
</ol>
<p>缺点：</p>
<ol>
<li>可能会导致系统有过多的具体命令类</li>
</ol>
<p>适合场景：</p>
<ol>
<li>系统需要调用者和接收者解耦</li>
<li>系统需要在不同的时间指定请求，将请求排队和执行请求。</li>
<li>系统需要支持命令的撤销和恢复操作</li>
<li>系统需要一组操作组合形成宏命令</li>
</ol>
<h3 id="解释器模式"><a href="#解释器模式" class="headerlink" title="解释器模式"></a>解释器模式</h3><p>解释器模式（Interpreter Pattern）：定义一个语言的文法，并且建立一个解释器来接收该语言中的句子，这里的语言是指使用规定格式和语法的代码。</p>
<ul>
<li>AbstractExpression（抽象表达式）</li>
<li>TerminalExpression（终结符表达式）</li>
<li>NonterminalExpression（非终结符表达式）</li>
<li>Context（环境类）</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 抽象表达式
abstract class AbstractExpression &#123;
    public abstract void interpret(Context ctx);
&#125;

&#x2F;&#x2F; 终结符表达式
class TerminalExpression extends AbstractExpression &#123;
    public void interpret(Context ctx)&#123;
        &#x2F;&#x2F; 终结符表达式的解释操作
    &#125;
&#125;

&#x2F;&#x2F; 非终结符表达式
class NonterminalExpression extends AbstractExpression &#123;
    private AbstractExpression left;
    private AbstractExpression right;
    
    public NonterminalExpression(AbstractExpression left, AbstractExpression right)&#123;
        this.left &#x3D; left;
        this.right &#x3D; right;
    &#125;
    
    public void interpret(Context ctx)&#123;
        &#x2F;&#x2F; 递归调用每一个组成部分的 interpret 方法
        &#x2F;&#x2F; 在递归调用时指定组成部分的连接方式，即非终结符的功能
    &#125;
&#125;

&#x2F;&#x2F; 环境类
class Context &#123;
    private HashMap map &#x3D; new HashMap();
    
    public void assign(String key, String value)&#123;
        &#x2F;&#x2F; 往环境类中设值
    &#125;
    
    public String lookup(String key)&#123;
        &#x2F;&#x2F; 获取存储在环境类中的值
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>优点：</p>
<ol>
<li>易于改变和扩展文法</li>
<li>每一条文法规则都可以表示一个类</li>
<li>实现文法较为容易</li>
<li>增加新的解释表达式较为方便，只需增加终结符表达式或非终结符表达式</li>
</ol>
<p>缺点：</p>
<ol>
<li>复杂文法难以维护，每一个规则都至少需要定义一个类</li>
<li>执行效率低，大量递归和循环</li>
</ol>
<p>适用场景：</p>
<ol>
<li>可以将一个需要解释执行的语言中的句子表示为一个抽象语法树</li>
<li>一些重复出现的问题可以用一种简单的语言来表达</li>
<li>一个语言的文法较为简单</li>
<li>执行效率不是关键问题</li>
</ol>
<h3 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h3><p>迭代器模式（Interator Pattern）：提供一个方法来访问聚合对象，而不是暴露这个对象的内部表示，其别名为游标。</p>
<ul>
<li>Iterator（抽象迭代器）</li>
<li>ConcreteIterator（具体迭代器）</li>
<li>Aggregate（抽象聚合类）</li>
<li>ConcreteAggregate（具体聚合类）</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 抽象迭代器
interface Iterator &#123;
    public void first();
    public void next();
    public boolean hasNext();
    public Object currentItem();
&#125;

&#x2F;&#x2F; 具体迭代器类
class ConcreteIterator implements Iterator &#123;
    private ConcreteAggregate objects;
    private int cursor;
    public ConcreteIterator(ConcreteAggregate objects)&#123;
        this.objects &#x3D; objects;
    &#125;
    
    public void first() &#123;&#125;;
    public void next() &#123;&#125;;
    public boolean hasNext() &#123;&#125;;
    public Object currentItem() &#123;&#125;;
&#125;

&#x2F;&#x2F; 抽象聚合类
interface Aggregate &#123;
    Iterator createIterator();
&#125;

&#x2F;&#x2F; 具体聚合类
class ConcreteAggregate implements Aggregate &#123;
    public Iterator createIterator()&#123;
        return new ConcreteIterator(this);
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>优点：</p>
<ol>
<li>支持不同的方式遍历一个聚合对象。</li>
<li>迭代器简化了聚合类，通过迭代器来实现聚合类的遍历等方法</li>
<li>迭代器引入抽象层，在增加新的聚合类和迭代器类都很方便</li>
</ol>
<p>缺点：</p>
<ol>
<li>迭代器模式将存储数据和遍历数据的职责分开，因此增加聚合类时相应要增加迭代器类，增加了系统的复杂性</li>
<li>抽象迭代器的设计难度较大，应充分考虑到系统未来的扩展</li>
</ol>
<p>适用场景：</p>
<ol>
<li>访问一个聚合对象的内容而无须暴露它的内部表示</li>
<li>需要为一个聚合对象提供多种遍历方式</li>
<li>为遍历不同的聚合结构提供一个统一的接口，在该接口的实现类中为不用的聚合类提供不同的遍历方式</li>
</ol>
<h3 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h3><p>中介者模式（Mediator Pattern）：用一个中介对象（中介者）来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变他们之间的交互。</p>
<ul>
<li>Mediator（抽象中介者）</li>
<li>ConcreteMediator（具体中介者）</li>
<li>Colleague（抽象同事类）</li>
<li>ConcreteColleague（具体同事类）</li>
</ul>
<p>中介类的两个作用：</p>
<ol>
<li>中转作用。通过中介者提供的中转作用，各个同事对象就不再显式引用其他同事，当需要其他同事通过中介者间接调用</li>
<li>协调作用。中介者可对同事的请求进一步处理，将同事成员之间的关系行为进行分离和封装</li>
</ol>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 抽象中介者
abstract class Mediator &#123;
    protected ArrayList&lt;Colleague&gt; colleagues;
    
    public void register(Colleagure colleague)&#123;
        colleagues.add(colleague);
    &#125;
    
    public abstract void operation();
&#125;

&#x2F;&#x2F; 具体中介者
class ConcreteMediator extends Mediator &#123;
    public void operation()&#123;
        ((Colleague)(colleagues.get(0))).method1();
    &#125;
&#125;

&#x2F;&#x2F; 抽象同事类
abstract class Colleague &#123;
    protected Mediator mediator;
    
    public Colleague(Mediator mediator)&#123;
        this.meditor &#x3D; mediator;
    &#125;
    
    public abstract void method1();
    
    public void method2()&#123;
        mediator.operation();
    &#125;
    
&#125;

&#x2F;&#x2F; 具体同事类
class ConcreteColleague extends Colleague &#123;
    public ConcreteColleague(Mediator mediator)&#123;
        super(mediator);
    &#125;
    
    public void method1()&#123;
        
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>优点：</p>
<ol>
<li>简化对象之间的交互</li>
<li>将各同事对象解耦</li>
<li>减少大量同事子类生成</li>
</ol>
<p>缺点：</p>
<ol>
<li>在具体中介类中包含了大量同事之间的交互细节，可能导致中介类过于复杂难以维护</li>
</ol>
<p>适用场景：</p>
<ol>
<li>系统中对象之间存在复杂的引用关系，系统结构混乱难以理解</li>
<li>一个对象由于引用了其他很多对象通信，导致难以复用该对象</li>
<li>想通过一个中间类来封装多个类中的行为，而又不想生成太多的子类</li>
</ol>
<h3 id="备忘录模式"><a href="#备忘录模式" class="headerlink" title="备忘录模式"></a>备忘录模式</h3><p>备忘录模式（Memento Pattern）：在不破坏封装的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样可以在以后对象恢复到原先保存的状态。</p>
<ul>
<li>Originator（原发器）</li>
<li>Memento（备忘录）</li>
<li>Caretaker（负责人）</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 原发器
public class Originator &#123;
    private String state;
    public Originator()&#123;&#125;
    
    public Memento createMemento()&#123;
        return new Memento(this);
    &#125;
    
    public void restoreMemento(Memento m)&#123;
        state &#x3D; m.state;
    &#125;
    
    &#x2F;&#x2F; getter&#x2F;setter
&#125;

&#x2F;&#x2F; 备忘录
class Memento &#123;
    private String state;
    
    public Memento(Originator o)&#123;
        state &#x3D; o.getState();
    &#125;
    
    &#x2F;&#x2F; getter&#x2F;setter
&#125;

&#x2F;&#x2F; 负责人
public class Caretaker &#123;
    private Memento memento;
    
    public Memento getMemento()&#123;
        return memento;
    &#125;
    
    &#x2F;&#x2F; getter&#x2F;setter
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>优点：</p>
<ol>
<li>提供一种状态恢复的实现机制</li>
<li>实现了对信息的封装，一个备忘录对象是一种原发器对象状态的表示</li>
</ol>
<p>缺点：</p>
<ol>
<li>资源消耗过大，每保存一次对象的状态都需要消耗一定的系统资源</li>
</ol>
<p>适用场景：</p>
<ol>
<li>保存一个对象在某一时刻的全部状态或部分状态</li>
<li>防止外界对象破坏一个对象历史状态的封装性，避免对象历史状态实现细节暴露给外界对象</li>
</ol>
<h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h3><p>观察者模式（Observer Pattern）：定义对象之间的一种一对多的依赖关系，使得每当一个对象状态发生改变时，其相关依赖对象皆得到通知并被自动更新。也可称为发布-订阅（Publish&#x2F;Subscribe）模式、模型-视图（Modal&#x2F;View）模式、源-监听器（Source&#x2F;Listener）模式或从属者（Dependents）模式。</p>
<ul>
<li>Subject（目标）</li>
<li>ConcreteSubject（具体目标）</li>
<li>Observer（观察者）</li>
<li>ConcreteObserver（具体观察者）</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 目标
abstract class Subject &#123;
    protected ArrayList&lt;Observer&gt; observers &#x3D; new ArrayList&lt;&gt;();
    
    public void attach(Observer observer)&#123;
        observers.add(observer);
    &#125;
    
    public void detach(Observer observer)&#123;
        observers.remove(oberver);
    &#125;
    
    public abstract void notify();
&#125;

&#x2F;&#x2F; 具体目标类
class ConcreteSubject extends Subject &#123;
    public void notify()&#123;
        for(Observer ob: observers)&#123;
            ob.update();
        &#125;
    &#125;
&#125;

&#x2F;&#x2F; 抽象观察类
interface Observer&#123;
    void update();
&#125;

&#x2F;&#x2F; 具体观察者
class ConcreteObserver implements Observer &#123;
    public void update()&#123;
        &#x2F;&#x2F; 具体响应代码
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>优点：</p>
<ol>
<li>实现了表示层和数据逻辑层的分离，定义了稳定的消息更新传递机制</li>
<li>在观察目标和观察者之间建立一个抽象的耦合</li>
<li>支持广播通信，简化一对多系统的设计</li>
<li>增加新的具体观察者无需修改原有系统代码，具体观察者和观察目标不存在关联关系时增加新的观察目标也很方便</li>
</ol>
<p>缺点：</p>
<ol>
<li>如果一个观察目标对象有很多直接和间接观察者，将所有的观察者通知很花时间</li>
<li>观察者和观察者目标之间存在循环依赖，观察目标触发循环调用可能导致系统崩溃</li>
<li>没有相应的机制让观察者知道所有观察的目标如何变化而仅仅知道观察目标发生了变化</li>
</ol>
<p>适用场景：</p>
<ol>
<li>一个抽象模型有两个方面，其中一个方面依赖于另一个方面</li>
<li>一个对象的改变导致一个或多个其他对象也发生改变</li>
<li>需要在系统中创建一个触发链</li>
</ol>
<h3 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h3><p>状态模式（State Pattern）：允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它的类。</p>
<ul>
<li>Context（环境类）</li>
<li>State（抽象状态类）</li>
<li>ConcreteState（具体状态类）</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 抽象状态类
abstract class State &#123;
    public abstract void handle();
&#125;

&#x2F;&#x2F; 具体状态类
class ConcreteState extends State &#123;
    public void handle()&#123;
        &#x2F;&#x2F; 方法具体实现代码
    &#125;
&#125;

&#x2F;&#x2F; 环境类
class Context &#123;
    private State state;
    private int value;
    
    public void setState(State state)&#123;
        this.state &#x3D; state;
    &#125;
    
    public void request()&#123;
        state.handle();
    &#125;
    
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>状态改变的两种方式：</p>
<ol>
<li>统一由环境类来负责状态之间的转换</li>
<li>由具体状态类负责状态之间的转换</li>
</ol>
<p>优点：</p>
<ol>
<li>封装状态的转换规则，对状态转换代码进行统一管理</li>
<li>将所有与某个状态有关的行为放到一个类中，只需要注入一个不同的状态对象</li>
<li>允许状态转换逻辑与状态对象合成一体，而不是一个提供巨大的条件语句块</li>
<li>可以让多个环境对象共享一个状态对象</li>
</ol>
<p>缺点：</p>
<ol>
<li>状态模式的使用增加系统中类和对象的个数</li>
<li>程序结构与实现较为复杂</li>
<li>开闭原则支持不好</li>
</ol>
<p>适合场景：</p>
<ol>
<li>对象的行为依赖它的状态，状态的改变将导致行为的变化</li>
<li>在代码中包含大量与对象状态有关的条件语句</li>
</ol>
<h3 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h3><p>策略模式（Strategy Pattern）：定义一系列算法类，将每一个算法封装起来，并让它们可以相互替换。策略模式让算法独立于使用它的客户而变化，也成为政策模式（Policy）。</p>
<ul>
<li>Context（环境类）</li>
<li>Strategy（抽象策略类）</li>
<li>ConcreteStrategy（具体策略类）</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 抽象策略类
abstract class AbstractStrategy&#123;
    public abstract void algorithm();
&#125;

&#x2F;&#x2F; 具体策略类
class ConcreteStrategy extends AbstractStrategy &#123;
    public void algorithm()&#123;
        &#x2F;&#x2F; 算法A
    &#125;
&#125;

&#x2F;&#x2F; 环境类
class Context &#123;
    private AbstractStrategy strategy;
    
    public void setStrategy(AbstractStrategy strategy)&#123;
        this.strategy &#x3D; strategy;
    &#125;
    
    public void algorithm()&#123;
        strategy.algorithm();
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>优点：</p>
<ol>
<li>完美支持开闭原则，用户可以在不修改原有系统代码的基础上增加新的算法或行为</li>
<li>提供类管理相关算法族的办法，恰当使用继承可以将公共的代码抽取到抽象策略类中</li>
<li>提供了替换继承关系的办法。</li>
<li>避免了多重条件选择语句</li>
<li>提供了算法复用机制，可以在不同环境类中使用这些策略</li>
</ol>
<p>缺点：</p>
<ol>
<li>客户端必须知道所有的策略类，然后决定使用哪一个</li>
<li>策略模式导致系统出现很多具体策略类</li>
<li>无法同时在客户端使用多个策略类</li>
</ol>
<p>适用场景：</p>
<ol>
<li>一个系统需要动态地在几种算法中选择一种</li>
<li>一个对象有很多的行为，这些行为转移到相应的具体策略类中可以避免使用难以维护的多重条件选择语句</li>
<li>不希望客户端知道复杂的、与算法相关的数据结构，在具体策略类中封装算法与相关的数据结构，提高算法的保密性与安全性</li>
</ol>
<h3 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h3><p>模板方法模式（Template Method Pattern）：定义一个操作中算法的框架，而将一些步骤延迟到子类中，模板方法使得子类可以不改变一个算法结构即可重定义该算法某些特定的步骤。</p>
<ul>
<li>AbstractClass（抽象类）</li>
<li>ConcreteClass（具体类）</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 抽象类
abstract class AbstractClass &#123;
    
    &#x2F;&#x2F; 模板方法
    public void templateMethod()&#123;
        primitiveOperation1();
        primitiveOperation2();
        primitiveOperation3();
    &#125;
    
    &#x2F;&#x2F; 具体方法
    public void primitiveOperation()&#123;
        &#x2F;&#x2F; 实现代码
    &#125;
    
    &#x2F;&#x2F; 抽象方法
	public abstract void primitiveOperation2();
    
    &#x2F;&#x2F; 钩子方法
    public void primitiveOperation3()&#123;&#125;
&#125;

&#x2F;&#x2F; 具体类
class ConcreteClass extends AbstractClass &#123;
    public void primitiveOperation2()&#123;
        &#x2F;&#x2F; 实现代码
    &#125;
    public void primitiveOperation3()&#123;
        &#x2F;&#x2F; 实现代码
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>优点：</p>
<ol>
<li>在子类实现详细的处理算法时并不会改变算法中的步骤的执行次序</li>
<li>将公共方法放入父类中，通过子类实现不同的行为，它鼓励使用继承来实现代码复用</li>
<li>实现反向控制结构，通过子类覆盖父类的钩子方法来决定某一特定步骤是否执行</li>
<li>不同子类提供的方法的不同实现，更换和增加子类很方便，符合单一职责原则和开闭原则</li>
</ol>
<p>缺点：</p>
<ol>
<li>需要为每一个基本方法的不同实现提供一个子类，如果父类可变方法太多，将导致类的个数增加，可结合桥接模式来设计</li>
</ol>
<p>适用场景：</p>
<ol>
<li>对一个复杂算法进行分割</li>
<li>各自类公共的行为应该提取并集中到一个公共父类中</li>
<li>通过子类来决定父类算法中某一个步骤需要执行，实现子类对父类的反向控制</li>
</ol>
<h3 id="访问者模式"><a href="#访问者模式" class="headerlink" title="访问者模式"></a>访问者模式</h3><p>访问者模式（Visitor Pattern）：提供一个作用于某对象结构中的各元素的操作表示，它使得可以在不改变各元素的类的前提下定义作用于这些元素的新操作。</p>
<ul>
<li>Visitor（抽象访问者）</li>
<li>ConcreteVisitor（具体访问者）</li>
<li>Element（抽象元素）</li>
<li>ConcreteElement（具体元素）</li>
<li>ObjectStructure（对象结构）</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 抽象访问者
abstract class Visitor &#123;
    public abstract void visit(ConcreteElementA elementA);
    public abstract void visit(ConcreteElementB elementB);
    
    public void visit(ConcreteElementC elemtentC)&#123;
        &#x2F;&#x2F; 元素 ConcreteELementC 操作代码
    &#125;
&#125;

&#x2F;&#x2F; 具体访问者
class ConcreteVisitor extends Visitor &#123;
    public void visit(ConcreteELementA elementA)&#123;
        &#x2F;&#x2F; 元素 ConcreteElementA 操作代码
    &#125;
    
    public void visit(ConcreteElementB elementB)&#123;
        &#x2F;&#x2F; 元素 ConcreteElementB 操作代码
    &#125;
&#125;

&#x2F;&#x2F; 抽象元素类
interface Element &#123;
    public void accept(Visitor visitor);
&#125;

&#x2F;&#x2F; 具体元素类
class ConcreteElement implements Element &#123;
    public void accept(Visitor visitor)&#123;
        visitor.visit(this);
    &#125;
    
    public void operationA()&#123;
        &#x2F;&#x2F; 业务方法
    &#125;
&#125;

&#x2F;&#x2F; 对象结构
class ObjectStructure &#123;
    private ArrayList&lt;Element&gt; list &#x3D; new ArrayList&lt;&gt;();
    
    public void accept(Visitor visitor)&#123;
        for(Element e: list)&#123;
            e.accept(visitor);
        &#125;
    &#125;
    
    public void addElement(Element element)&#123;
        list.add(element);
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>优点：</p>
<ol>
<li>增加新的访问操作很方便</li>
<li>将有关元素对象的访问集合到一个访问者对象中</li>
<li>让用户能够在不修改原有元素层次结构的情况下，定义作用于该层次结构的操作</li>
</ol>
<p>缺点：</p>
<ol>
<li>增加新的元素类很困难</li>
<li>破坏封装，访问者模式要求访问者对象访问并调用每一个元素对象的操作</li>
</ol>
<p>适用场景：</p>
<ol>
<li>一个对象结构包含多个类型的对象，希望对这些对象实施一些依赖具体类型的操作</li>
<li>需要对一个对象结构中的对象进行很多不同的并且不相关的操作</li>
<li>对象结构中对象对应的类很少变化，但经常需要在此对象结构上定义新的操作</li>
</ol>

                
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="/about" rel="external nofollow noreferrer">John Faye</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://jojofaye99.github.io/2024/03/11/designpattern/">https://jojofaye99.github.io/2024/03/11/designpattern/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="/about" target="_blank">John Faye</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/Notes/">
                                    <span class="chip bg-color">Notes</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
        </div>
    </div>

    

    

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2024/10/28/javawebservlet/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/3.jpg" class="responsive-img" alt="Servlet">
                        
                        <span class="card-title">Servlet</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2024-10-28
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/Java/" class="post-category">
                                    Java
                                </a>
                            
                            <a href="/categories/Java/Web/" class="post-category">
                                    Web
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/Note/">
                        <span class="chip bg-color">Note</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2024/02/08/corejava/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/1.jpg" class="responsive-img" alt="CoreJava Volume Ⅰ">
                        
                        <span class="card-title">CoreJava Volume Ⅰ</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2024-02-08
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/Java/" class="post-category">
                                    Java
                                </a>
                            
                            <a href="/categories/Java/Reading/" class="post-category">
                                    Reading
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/Note/">
                        <span class="chip bg-color">Note</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>


<script>
    $('#articleContent').on('copy', function (e) {
        // IE8 or earlier browser is 'undefined'
        if (typeof window.getSelection === 'undefined') return;

        var selection = window.getSelection();
        // if the selection is short let's not annoy our users.
        if (('' + selection).length < Number.parseInt('50')) {
            return;
        }

        // create a div outside of the visible area and fill it with the selected text.
        var bodyElement = document.getElementsByTagName('body')[0];
        var newdiv = document.createElement('div');
        newdiv.style.position = 'absolute';
        newdiv.style.left = '-99999px';
        bodyElement.appendChild(newdiv);
        newdiv.appendChild(selection.getRangeAt(0).cloneContents());

        // we need a <pre> tag workaround.
        // otherwise the text inside "pre" loses all the line breaks!
        if (selection.getRangeAt(0).commonAncestorContainer.nodeName === 'PRE' || selection.getRangeAt(0).commonAncestorContainer.nodeName === 'CODE') {
            newdiv.innerHTML = "<pre>" + newdiv.innerHTML + "</pre>";
        }

        var url = document.location.href;
        newdiv.innerHTML += '<br />'
            + '来源: 造梦空间<br />'
            + '文章作者: John Faye<br />'
            + '文章链接: <a href="' + url + '">' + url + '</a><br />'
            + '本文章著作权归作者所有，任何形式的转载都请注明出处。';

        selection.selectAllChildren(newdiv);
        window.setTimeout(function () {bodyElement.removeChild(newdiv);}, 200);
    });
</script>


<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>


  <!-- 是否加载使用自带的 prismjs. -->
  <script type="text/javascript" src="/libs/prism/prism.min.js"></script>


<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>



    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




    <footer class="page-footer bg-color">
    
        <link rel="stylesheet" href="/libs/aplayer/APlayer.min.css">
<style>
    .aplayer .aplayer-lrc p {
        
        display: none;
        
        font-size: 12px;
        font-weight: 700;
        line-height: 16px !important;
    }

    .aplayer .aplayer-lrc p.aplayer-lrc-current {
        
        display: none;
        
        font-size: 15px;
        color: #42b983;
    }

    
    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body {
        left: -66px !important;
    }

    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover {
        left: 0px !important;
    }

    
</style>
<div class="">
    
    <div class="row">
        <meting-js class="col l8 offset-l2 m10 offset-m1 s12"
                   server="netease"
                   type="playlist"
                   id="503838841"
                   fixed='true'
                   autoplay='false'
                   theme='#42b983'
                   loop='all'
                   order='random'
                   preload='auto'
                   volume='0.7'
                   list-folded='true'
        >
        </meting-js>
    </div>
</div>

<script src="/libs/aplayer/APlayer.min.js"></script>
<script src="/libs/aplayer/Meting.min.js"></script>

    

    <div class="container row center-align"
         style="margin-bottom: 0px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2021-2025</span>
            
            <a href="/about" target="_blank">John Faye</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            
            <br>
            
            
            
            
            
            <br>

            <!-- 运行天数提醒. -->
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link ">
    <a href="https://github.com/jojofaye99" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:1358282083@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>







    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=1358282083" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 1358282083" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>







</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 白天和黑夜主题 -->
<div class="stars-con">
    <div id="stars"></div>
    <div id="stars2"></div>
    <div id="stars3"></div>  
</div>

<script>
    function switchNightMode() {
        $('<div class="Cuteen_DarkSky"><div class="Cuteen_DarkPlanet"></div></div>').appendTo($('body')),
        setTimeout(function () {
            $('body').hasClass('DarkMode') 
            ? ($('body').removeClass('DarkMode'), localStorage.setItem('isDark', '0'), $('#sum-moon-icon').removeClass("fa-sun").addClass('fa-moon')) 
            : ($('body').addClass('DarkMode'), localStorage.setItem('isDark', '1'), $('#sum-moon-icon').addClass("fa-sun").removeClass('fa-moon')),
            
            setTimeout(function () {
            $('.Cuteen_DarkSky').fadeOut(1e3, function () {
                $(this).remove()
            })
            }, 2e3)
        })
    }
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    

    
    
    

    <!-- 雪花特效 -->
    

    <!-- 鼠标星星特效 -->
    

     
        <script src="https://ssl.captcha.qq.com/TCaptcha.js"></script>
        <script src="/libs/others/TencentCaptcha.js"></script>
        <button id="TencentCaptcha" data-appid="xxxxxxxxxx" data-cbfn="callback" type="button" hidden></button>
    

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    <script src="/libs/others/clicklove.js" async="async"></script>
    
    

    

    

    <!--腾讯兔小巢-->
    
    

    

    
    <script type="text/javascript" src="/libs/background/ribbon-dynamic.js" async="async"></script>
    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
